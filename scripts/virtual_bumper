#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import numpy as np
from threading import RLock
from timeit import default_timer as timer

import rospy
from std_msgs.msg import ColorRGBA
from ros_numpy import msgify, numpify
from sensor_msgs.msg import PointCloud2
from geometry_msgs.msg import Twist, Vector3, Point
from tf2_ros import Buffer, TransformListener
from visualization_msgs.msg import Marker, MarkerArray
from tf2_sensor_msgs.tf2_sensor_msgs import do_transform_cloud

np.set_printoptions(precision=2)


class VirtualBumper(object):
    def __init__(self):
        self.robot_frame = rospy.get_param('~robot_frame', 'base_link')
        self.max_age = rospy.get_param('~max_age', 1.0)
        clearance_box = rospy.get_param('~clearance_box', [[-0.6, 0.6],
                                                           [-0.5, 0.5],
                                                           [ 0.0, 0.8]])
        self.clearance_box = np.array(clearance_box)
        self.min_points_obstacle = rospy.get_param('~min_points_obstacle', 1)
        self.keep_clouds = int(rospy.get_param('~keep_clouds', 1))
        
        self.min_points_obstacle = rospy.get_param('~min_points_obstacle', 20)
        self.robot_length = rospy.get_param('~robot_length', 0.8)
        self.robot_width = rospy.get_param('~robot_width', 0.6) 

        self.cloud_lock = RLock()
        self.clouds = [None] * self.keep_clouds
        self.i_cloud = 0
        self.blocked = False

        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer)

        self.cmd_pub = rospy.Publisher('output_cmd_vel', Twist, queue_size=2)
        self.cloud_pub = rospy.Publisher('obstacle_cloud', PointCloud2, queue_size=2)
        self.centroid_pub = rospy.Publisher('obstacle_centroids', MarkerArray, queue_size=2)
        self.markers_pub = rospy.Publisher('~markers', MarkerArray, queue_size=2)

        self.cmd_sub = rospy.Subscriber('input_cmd_vel', Twist, self.receive_cmd, queue_size=2)
        self.cloud_sub = rospy.Subscriber('input_cloud', PointCloud2, self.receive_cloud, queue_size=2)

    def transform_cloud(self, msg):
        transform = self.tf_buffer.lookup_transform(self.robot_frame, msg.header.frame_id, rospy.Time(0))
        msg_out = do_transform_cloud(msg, transform)
        msg_out.header.stamp = msg.header.stamp
        return msg_out

    def filter_cloud(self, cloud):
        valid_indices = ~np.isnan(cloud['x']) & ~np.isnan(cloud['y'])
        cloud = cloud[valid_indices]

        mask = ~((np.abs(cloud['x']) < self.robot_length / 2) & (np.abs(cloud['y']) < self.robot_width / 2))
        filtered_cloud = cloud[mask]
        return filtered_cloud

    def receive_cloud(self, msg):
        t = timer()
        if msg.header.frame_id != self.robot_frame:
            msg = self.transform_cloud(msg)
        
        assert isinstance(msg, PointCloud2)
        assert msg.header.frame_id == self.robot_frame

        age = (rospy.Time.now() - msg.header.stamp).to_sec()
        if False and age > self.max_age:
            rospy.logwarn('Discarding cloud %.1f s > %.1f s old.', age, self.max_age)
            return

        cloud = numpify(msg).ravel()
        if cloud is not None:
            cloud = self.filter_cloud(cloud)

        with self.cloud_lock:
            i = self.i_cloud % self.keep_clouds
            self.clouds[i] = cloud
            self.i_cloud += 1
        t = timer() - t
        rospy.logdebug(f'{cloud.size} points received in slot {i} ({t:.3f} s).')

    def obstacle_cloud(self, cloud):
        obstacles = np.ones(cloud.shape, dtype=bool)
        for i, f in enumerate(('x', 'y', 'z')):
            obstacles = obstacles & ((cloud[f] >= self.clearance_box[i, 0])
                                     & (cloud[f] <= self.clearance_box[i, 1]))

        obstacle_cloud = cloud[obstacles]
        return obstacle_cloud
    
    def full_obstacle_cloud(self):
        obstacle_clouds = []
        with self.cloud_lock:
            for cloud in self.clouds:
                if cloud is None:
                    rospy.logwarn_throttle(1.0, 'Missing input clouds to check clearance.')
                    continue
                obstacle_cloud = self.obstacle_cloud(cloud)
                obstacle_clouds.append(obstacle_cloud)

        if not obstacle_clouds:
            return None
        
        obstacle_cloud = np.concatenate(obstacle_clouds)
        return obstacle_cloud

    def check_clearance(self):
        infeas_dircs = np.array([False, False, False, False], dtype=bool)  # [front, back, left, right] 
        obstacle_cloud = self.full_obstacle_cloud()

        if obstacle_cloud is not None:
            centroids = self.calculate_centroids(obstacle_cloud)
            infeas_dircs = self.check_directions(centroids)
        # rospy.loginfo(f"Infeasible directions are: {infeas_dircs}")
        return infeas_dircs, obstacle_cloud

    def clearance_ns(self):
        return f'{self.robot_frame}/clearance'

    def clearance_marker(self, free):
        marker = Marker()
        marker.header.frame_id = self.robot_frame
        marker.header.stamp = rospy.Time.now()
        marker.ns = self.clearance_ns()
        marker.id = 0
        marker.action = Marker.MODIFY
        marker.type = Marker.CUBE
        marker.pose.orientation.w = 1.
        marker.scale = Vector3(*(self.clearance_box[:, 1] - self.clearance_box[:, 0]))
        if free:
            marker.color = ColorRGBA(0., 1., 0., 0.25)
        else:
            marker.color = ColorRGBA(1., 0., 0., 0.5)
        marker.frame_locked = True
        marker.lifetime = rospy.Duration(1.0)
        return marker
    
    def calculate_centroids(self, cloud):
        if cloud is None or cloud.size == 0:
            return []
        points = np.array([(cloud['x'][i], cloud['y'][i], cloud['z'][i]) for i in range(len(cloud))])
        centroids = []

        # Clustering using distance threshold.
        threshold = 0.35
        while points.size > 0:
            current_cluster = [points[0]]
            points = np.delete(points, 0, 0)
            i = 0
            while i < len(points):
                if np.linalg.norm(points[i] - current_cluster[-1]) < threshold:
                    current_cluster.append(points[i])
                    points = np.delete(points, i, 0)
                else:
                    i += 1
            if len(current_cluster) > self.min_points_obstacle:
                centroid = np.mean(current_cluster, axis=0)
                centroids.append(centroid)

        self.publish_centroids(centroids)
        return centroids

    def get_infeasible_direction(self, x, y):
        infeas_dircs = np.array([False, False, False, False], dtype=bool)  # [front, back, left, right]
        if x > self.robot_length / 2:     
            infeas_dircs[0] = True          # (0,1)
            if y > self.robot_width / 2: 
                infeas_dircs[2] = True      # (0,0)
            elif y < -self.robot_width / 2:
                infeas_dircs[3] = True      # (0,2)
        elif x < -self.robot_length / 2:
            infeas_dircs[1] = True          # (2,1)
            if y > self.robot_width / 2:
                infeas_dircs[2] = True      # (2,0)
            elif y < -self.robot_width / 2:
                infeas_dircs[3] = True      # (2,2)
        elif x < self.robot_length / 2 and x > -self.robot_length / 2:
            if y > self.robot_width / 2:    # (1,0)
                infeas_dircs[2] = True
            elif y < -self.robot_width / 2: # (1,2)
                infeas_dircs[3] = True
        return infeas_dircs

    def check_directions(self, centroids):
        infeas_dircs = np.array([False, False, False, False], dtype=bool)  # [front, back, left, right]
        for centroid in centroids:
            x, y, z = centroid
            infeas_dircs = np.logical_or(infeas_dircs, self.get_infeasible_direction(x, y))
        return infeas_dircs

    def publish_centroids(self, centroids):
        t = timer()
        marker_array = MarkerArray()
        for i, centroid in enumerate(centroids):
            marker = Marker()
            marker.header.frame_id = self.robot_frame
            marker.header.stamp = rospy.Time.now()
            marker.ns = 'centroids'
            marker.id = i
            marker.type = Marker.SPHERE
            marker.action = Marker.ADD
            marker.pose.position = Point(*centroid)
            marker.pose.orientation.w = 1.0
            marker.scale.x = 0.1
            marker.scale.y = 0.1
            marker.scale.z = 0.1
            marker.color = ColorRGBA(0, 0, 1, 1)
            marker.lifetime = rospy.Duration(1.0)
            marker_array.markers.append(marker)
        self.centroid_pub.publish(marker_array)
        t = timer() - t
        rospy.logdebug(f'Publish centroids: {t:.3f} s.')

    def publish_clearance_marker(self, free):
        t = timer()
        msg = MarkerArray([self.clearance_marker(free)])
        self.markers_pub.publish(msg)
        t = timer() - t
        rospy.logdebug(f'Publish clearance: {t:.3f} s.')

    def publish_obstacle_cloud(self, cloud):
        t = timer()
        cloud = msgify(PointCloud2, cloud)
        cloud.header.frame_id = self.robot_frame
        cloud.header.stamp = rospy.Time.now()
        self.cloud_pub.publish(cloud)
        t = timer() - t
        rospy.logdebug(f'Publish obstacle cloud: {t:.3f} s.')

    def receive_cmd(self, msg):
        assert isinstance(msg, Twist)

        # Check clearance.
        infeas_dircs, obstacle_cloud = self.check_clearance()
        rospy.loginfo(f"Infeasible directions: {infeas_dircs}")
        
        free = not np.any(infeas_dircs)

        # Publish clearance markers.
        self.publish_clearance_marker(free)
        if obstacle_cloud is not None:
            self.publish_obstacle_cloud(obstacle_cloud)

        # Check if velocity is feasible.
        vel_x = msg.linear.x
        vel_ang = msg.angular.z

        if infeas_dircs[0] and vel_x > 0:
            vel_x = 0
            rospy.logwarn("Blocked by obstacle in front.")
        if infeas_dircs[1] and vel_x < 0:
            vel_x = 0
            rospy.logwarn("Blocked by obstacle in back.")
        if infeas_dircs[2] and vel_ang > 0:
            vel_ang = 0
            rospy.logwarn("Blocked by obstacle on left.")
        if infeas_dircs[3] and vel_ang < 0:
            vel_ang = 0
            rospy.logwarn("Blocked by obstacle on right")
        
        msg.linear.x = vel_x
        msg.angular.z = vel_ang
        self.cmd_pub.publish(msg)

if __name__ == '__main__':
    rospy.init_node('virtual_bumper', log_level=rospy.INFO)
    node = VirtualBumper()
    rospy.spin()
